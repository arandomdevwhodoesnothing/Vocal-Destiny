<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOCAL DESTINY</title>
    <style>
        /* ... (styling same as before, plus below) ... */
        .visitor-badge {
            background: #3a2e4a;
            color: #e2ccff;
            padding: 0.5rem 1.2rem;
            border-radius: 3rem;
            display: inline-block;
            margin-bottom: 1.5rem;
            border: 1px solid #a587cf;
            font-weight: 600;
        }
        .warning-box {
            background: #33202a;
            border-left: 6px solid #ff7e7e;
            padding: 1.2rem;
            border-radius: 1rem;
            margin-bottom: 1.5rem;
            color: #ffcece;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üë• VOCAL DESTINY</h1>
            <div class="sub">Your voice gets ONE name. Chosen by real strangers.</div>
        </header>

        <!-- VISITOR IDENTITY - ANONYMOUS BUT PERSISTENT -->
        <div class="visitor-badge" id="visitorBadge">
            üîë Your visitor ID: <span id="visitorId">loading...</span>
        </div>

        <div class="warning-box" id="voteWarning" style="display: none;">
            ‚ö†Ô∏è You have already voted on this voice. Each person gets ONE vote per voice.
        </div>

        <!-- RECORD YOUR VOICE PANEL -->
        <div class="panel">
            <!-- ... (same recording UI) ... -->
        </div>

        <!-- ALL RECORDED VOICES -->
        <h2 style="margin-bottom:1.2rem;">üó≥Ô∏è Voices needing names</h2>
        <div id="recordingsGallery" class="recordings-list"></div>

        <div class="footer-note">
            <strong>üîí REAL CONSENSUS:</strong> Each visitor gets a unique anonymous ID stored in their browser. 
            One vote per voice per person. You cannot vote twice. You cannot vote for yourself. 
            When 3 <strong>different people</strong> agree on a name, it becomes permanent.
        </div>
    </div>

    <script>
        (function() {
            "use strict";

            // =============================================
            // REAL MULTI-USER SYSTEM i guess 
            // No fake votes. Each browser = one identity.
            // =============================================

            // ---------- UNIQUE VISITOR ID ----------
            // Stored permanently in browser. Cannot be changed easily.
            // This simulates "different people" visiting the site.
            function getVisitorId() {
                let id = localStorage.getItem('vocal_destiny_visitor_id');
                if (!id) {
                    // Generate a real anonymous unique ID
                    id = 'visitor_' + Date.now() + '_' + Math.random().toString(36).substring(2) + '_' + Math.random().toString(36).substring(2);
                    localStorage.setItem('vocal_destiny_visitor_id', id);
                }
                return id;
            }

            const VISITOR_ID = getVisitorId();
            document.getElementById('visitorId').textContent = VISITOR_ID.substring(0, 12) + '...';

            // ---------- INDEXED DB SETUP ----------
            // (same as before, but with voter tracking)
            let db;
            const DB_NAME = 'VocalDestinyRealDB';
            const STORE_NAME = 'recordings';

            let recordings = [];

            // Initialize DB
            function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, 3);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        db = request.result;
                        loadRecordingsFromDB().then(() => renderGallery());
                        resolve(db);
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            }

            // Save recording
            function saveRecordingToDB(recording) {
                return new Promise((resolve, reject) => {
                    const tx = db.transaction(STORE_NAME, 'readwrite');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.put(recording);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            // Load all recordings
            function loadRecordingsFromDB() {
                return new Promise((resolve, reject) => {
                    if (!db) return resolve([]);
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => {
                        recordings = request.result.map(rec => ({
                            ...rec,
                            audioBlob: rec.audioBlob
                        }));
                        renderGallery();
                        resolve(recordings);
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            // ---------- RECORDING ----------
            // (standard MediaRecorder code - shortened for brevity)
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            let currentRecordingBlob = null;

            // DOM elements
            const recordBtn = document.getElementById('recordBtn');
            const playbackBtn = document.getElementById('playbackBtn');
            const statusMsg = document.getElementById('statusMessage');
            const indicator = document.getElementById('recordIndicator');
            const galleryEl = document.getElementById('recordingsGallery');
            const voteWarning = document.getElementById('voteWarning');

            // Setup microphone
            async function setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    
                    mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(audioChunks, { type: 'audio/webm' });
                        currentRecordingBlob = blob;
                        playbackBtn.disabled = false;
                        
                        // New recording - with owner ID (who recorded it)
                        const id = 'voice_' + Date.now() + '_' + Math.random().toString(36).substring(2);
                        const newRecording = {
                            id: id,
                            audioBlob: blob,
                            timestamp: Date.now(),
                            ownerId: VISITOR_ID,  // IMPORTANT: track who recorded this
                            suggestedNames: [],
                            destinyName: null,
                            consensus: false,
                            voters: {}  // Track which visitor IDs have voted on which names
                        };

                        recordings.push(newRecording);
                        await saveRecordingToDB(newRecording);
                        renderGallery();
                        
                        statusMsg.textContent = 'Voice recorded. Others will name you.';
                        indicator.className = 'indicator has-clip';
                        audioChunks = [];
                    };
                    statusMsg.textContent = 'Ready.';
                    return true;
                } catch (err) {
                    statusMsg.textContent = 'Microphone access denied.';
                    return false;
                }
            }

            // ---------- VOTING WITH REAL IDENTITY CHECKS ----------
            function suggestName(recordingId, suggestedName) {
                const recording = recordings.find(r => r.id === recordingId);
                if (!recording) return;

                // RULE 1: Cannot vote on your own voice
                if (recording.ownerId === VISITOR_ID) {
                    alert('You cannot name your own voice. Let others name you.');
                    return;
                }

                const cleanName = suggestedName.trim();
                if (cleanName.length < 2) return;

                // Initialize tracking structures
                if (!recording.suggestedNames) recording.suggestedNames = [];
                if (!recording.voters) recording.voters = {};

                // RULE 2: Check if this visitor has already voted on THIS voice
                if (recording.voters[VISITOR_ID]) {
                    // Already voted on this voice at all
                    voteWarning.style.display = 'block';
                    setTimeout(() => { voteWarning.style.display = 'none'; }, 3000);
                    return;
                }

                // Find existing suggestion
                let suggestion = recording.suggestedNames.find(s => s.name.toLowerCase() === cleanName.toLowerCase());
                
                if (suggestion) {
                    // Add vote
                    suggestion.votes = (suggestion.votes || 0) + 1;
                    if (!suggestion.voters) suggestion.voters = [];
                    suggestion.voters.push(VISITOR_ID);
                } else {
                    // New suggestion
                    suggestion = {
                        name: cleanName,
                        votes: 1,
                        voters: [VISITOR_ID]
                    };
                    recording.suggestedNames.push(suggestion);
                }

                // Mark this visitor as having voted on this recording
                recording.voters[VISITOR_ID] = {
                    votedFor: suggestion.name,
                    timestamp: Date.now()
                };

                // Sort by votes
                recording.suggestedNames.sort((a, b) => b.votes - a.votes);

                // RULE 3: Need 3 DIFFERENT people (unique visitor IDs)
                if (suggestion.votes >= 3 && !recording.consensus) {
                    recording.destinyName = suggestion.name;
                    recording.consensus = true;
                }

                // Save and refresh
                saveRecordingToDB(recording);
                renderGallery();
            }

            // ---------- RENDER WITH VOTE STATUS ----------
            function renderGallery() {
                if (!galleryEl) return;

                if (recordings.length === 0) {
                    galleryEl.innerHTML = `<div style="padding:2rem; text-align:center; background:#1a212c; border-radius:2rem;">
                        üïäÔ∏è No voices yet. Record yours to begin.
                    </div>`;
                    return;
                }

                const sorted = [...recordings].sort((a,b) => b.timestamp - a.timestamp);

                galleryEl.innerHTML = sorted.map(rec => {
                    const hasConsensus = rec.consensus && rec.destinyName;
                    const suggestions = rec.suggestedNames || [];
                    const isOwnVoice = rec.ownerId === VISITOR_ID;
                    const hasVoted = rec.voters && rec.voters[VISITOR_ID];
                    
                    return `
                        <div class="recording-card" style="${hasConsensus ? 'border-left-color: #ffd966;' : ''}">
                            <div class="recording-header">
                                <span class="voice-id">üîä ${rec.id.slice(0,8)}...</span>
                                <span style="color:#9ab8d9;">
                                    ${isOwnVoice ? 'üé§ YOUR VOICE' : 'üë§ Another visitor'}
                                </span>
                            </div>
                            
                            ${hasConsensus 
                                ? `<div>
                                        <span class="consensus-badge">‚ö° DESTINY SEALED ‚ö°</span>
                                        <div class="destiny-name">‚Äú${rec.destinyName}‚Äù</div>
                                        <span style="color:#aad9aa;">Named by ${suggestions.find(s => s.name === rec.destinyName)?.votes || 3} different people</span>
                                   </div>`
                                : `<div style="margin-bottom:0.8rem;">
                                    ${isOwnVoice 
                                        ? '<span style="color:#ffd966;">‚è≥ Waiting for others to name you...</span>' 
                                        : '<span style="color:#b8d0ff;">‚è≥ Need 3 different people to agree</span>'}
                                   </div>`
                            }

                            <div class="name-suggestion-area">
                                ${!isOwnVoice && !hasConsensus && !hasVoted 
                                    ? `<input type="text" id="input-${rec.id}" class="suggestion-input" placeholder="Listen first, then suggest a name..." />
                                       <button class="suggest-btn" data-id="${rec.id}">Suggest & Vote</button>`
                                    : isOwnVoice 
                                        ? '<span style="color:#99aacc;">‚ú® You cannot name yourself</span>'
                                        : hasVoted 
                                            ? '<span style="color:#aad9aa;">‚úÖ You voted on this voice</span>'
                                            : hasConsensus
                                                ? '<span style="color:#ffd966;">üîÆ Destiny fulfilled</span>'
                                                : ''
                                }
                                <button class="btn" style="padding:0.8rem 1.2rem;" onclick="window.playBlobById('${rec.id}')">üîä Listen</button>
                            </div>

                            <div class="suggestion-list">
                                ${suggestions.length > 0 
                                    ? `<strong>üó≥Ô∏è Community suggestions (${suggestions.reduce((acc, s) => acc + (s.voters?.length || 0), 0)} total votes):</strong><br>` + 
                                        suggestions.map(s => 
                                            `<span style="display:inline-block; background:#2d384a; padding:0.2rem 0.8rem; border-radius:2rem; margin:0.3rem;">
                                                ${s.name} 
                                                <span class="vote-badge">${s.votes} ${s.votes === 1 ? 'person' : 'people'}</span>
                                                ${s.voters?.includes(VISITOR_ID) ? '‚úì' : ''}
                                            </span>`
                                        ).join(' ')
                                    : '<span style="color:#859bb3;">No suggestions yet. Be the first to name this voice.</span>'
                                }
                            </div>
                        </div>
                    `;
                }).join('');

                // Attach suggest button listeners
                document.querySelectorAll('.suggest-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.id;
                        const input = document.getElementById(`input-${id}`);
                        const name = input.value.trim();
                        if (name) {
                            suggestName(id, name);
                            input.value = '';
                        }
                    });
                });
            }

            // Playback helper
            window.playBlobById = function(id) {
                const rec = recordings.find(r => r.id === id);
                if (rec && rec.audioBlob) {
                    const url = URL.createObjectURL(rec.audioBlob);
                    new Audio(url).play();
                }
            };

            // ---------- EVENT LISTENERS ----------
            recordBtn.addEventListener('click', async () => {
                if (!mediaRecorder) await setupMicrophone();
                if (mediaRecorder?.state === 'recording') {
                    mediaRecorder.stop();
                    recordBtn.classList.remove('recording');
                    recordBtn.innerHTML = '<span>üé§</span> Record Your Voice';
                } else {
                    audioChunks = [];
                    mediaRecorder?.start();
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '<span>‚èπÔ∏è</span> Stop Recording';
                    statusMsg.textContent = 'Recording...';
                    indicator.className = 'indicator recording';
                }
            });

            playbackBtn.addEventListener('click', () => {
                if (currentRecordingBlob) {
                    const url = URL.createObjectURL(currentRecordingBlob);
                    new Audio(url).play();
                }
            });

            // Initialize
            initDB().catch(console.error);
        })();
    </script>
</body>
</html
